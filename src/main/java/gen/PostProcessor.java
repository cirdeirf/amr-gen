package gen;

import dag.AlignedWord;
import dag.AlignmentType;
import dag.Amr;
import dag.Vertex;
import edu.berkeley.nlp.lm.ArrayEncodedNgramLanguageModel;
import edu.berkeley.nlp.lm.collections.BoundedList;
import edu.stanford.nlp.ling.Datum;
import misc.StaticHelper;
import misc.WordLists;
import ml.DenomMaxentModel;
import ml.Prediction;

import java.util.*;
import java.util.stream.Collectors;

/**
 * This class performs post-processing as described in the thesis.
 */
public class PostProcessor {
    private final ArrayEncodedNgramLanguageModel<String> lm;
    private final NNLanguageModel nnLM;
    private final DenomMaxentModel denomMaxentModel;

    // hyperparameters used by the post processor
    public double articleLmWeight;
    public double defaultArticlePredScore;
    public double defaultArticleSmoothing;
    public double articleAdditionHandicap;
    public double linkRemovalHandicap;

    /**
     * Creates a new PostProcessor.
     * @param lm the language model to be used for post processing
     * @param denomMaxentModel the maximum entropy model to be used for
     * denominator probabilities
     */
    public PostProcessor(ArrayEncodedNgramLanguageModel<String> lm,
        NNLanguageModel nnLM, DenomMaxentModel denomMaxentModel) {
        this.lm = lm;
        this.nnLM = nnLM;
        this.denomMaxentModel = denomMaxentModel;
    }

    /**
     * Post-processes a list of AMR graphs.
     * @param amrs the AMR graphs to post-process
     * @return the sentences generated from the AMR graphs
     */
    public List<String> postProcess(List<Amr> amrs) {
        List<String> ret = new ArrayList<>();
        for (Amr amr : amrs) {
            PartialTransitionFunction backup = new PartialTransitionFunction();
            backup.addCopy(amr.partialTransitionFunction);
            postProcess(amr);

            String generatedSentence = amr.yield(amr.partialTransitionFunction);

            // remove duplicate words from the realization
            generatedSentence =
                StaticHelper.removeDuplicateWords(generatedSentence);

            // add spaces before "'s" to reflect tokenization and convert the
            // generated sentence to lower case
            generatedSentence =
                generatedSentence.replace("'s", " 's").toLowerCase();

            // for sentences that consist of only two words, we remove articles
            if (generatedSentence.matches("the [A-z]+"))
                generatedSentence = generatedSentence.replace("the ", "");

            ret.add(generatedSentence);
            amr.partialTransitionFunction = backup;
        }
        return ret;
    }

    /**
     * Post-processes a single AMR graph.
     * @param amr the AMR graph to post-process
     */
    public void postProcess(Amr amr) {
        if (amr.partialTransitionFunction == null)
            throw new AssertionError(
                "Postprocessing an AMR graph is not possible without a partial transition function.");
        List<AlignedWord> result = amr.yieldList(amr.partialTransitionFunction);
        postProcess(amr, result);
    }

    /**
     * Post-processes a single AMR graph.
     * @param amr the AMR graph to post-process
     * @param result the sentence generated by the transition system,
     * represented by a list of {@link AlignedWord}s.
     */
    private void postProcess(Amr amr, List<AlignedWord> result) {
        for (Vertex v : amr.dag) {
            if (amr.partialTransitionFunction.pos.containsKey(v)
                && v.isPropbankEntry()) {
                v.setPos(amr.partialTransitionFunction.pos.get(v));
            }
        }

        for (AlignedWord aw : result) {
            // check whether words corresponding to links should be removed
            // according to the language model
            if (aw.type == AlignmentType.TRANSLATION && aw.alignment.isLink()
                && !aw.word.isEmpty()) {
                double scoreWithArticle =
                    scoreNonemptyContext(aw, result, 2, false);
                double scoreWithoutArticle =
                    scoreNonemptyContext(aw, "", result, 2, false);

                if (scoreWithoutArticle
                    > scoreWithArticle * linkRemovalHandicap) {
                    aw.word = "";
                    amr.partialTransitionFunction.realization.put(
                        aw.alignment, aw.word);
                }
            }
        }

        for (AlignedWord aw : result) {
            // add or remove articles according to the language model
            String pos = amr.partialTransitionFunction.pos.get(aw.alignment);
            if (aw.type == AlignmentType.ARTICLE && pos != null
                && pos.equals("NN")) {
                if (aw.alignment.isPropbankEntry())
                    aw.alignment.setPos("NN");
                List<Prediction> articlePredictions = new ArrayList<>();

                String numerus =
                    amr.partialTransitionFunction.number.getOrDefault(
                        aw.alignment, GoldSyntacticAnnotations.SINGULAR);
                String real =
                    amr.partialTransitionFunction.realization.get(aw.alignment);

                List<Datum<String, String>> articleDatumList =
                    denomMaxentModel.toDatumList(
                        amr, aw.alignment, true, numerus, real);
                if (!articleDatumList.isEmpty()) {
                    Datum<String, String> articleDatum =
                        articleDatumList.get(0);
                    List<Prediction> preds =
                        denomMaxentModel.getNBestSorted(articleDatum);
                    for (Prediction p : preds) {
                        Prediction articlePred = new Prediction(
                            p.getValue().replace("-", ""), p.getScore());
                        articlePredictions.add(articlePred);
                    }
                }

                if (!canHaveArticle(amr, result, aw)) {
                    aw.word = "";
                    amr.partialTransitionFunction.denominator.put(
                        aw.alignment, aw.word);
                    continue;
                }

                double thePredScore = defaultArticlePredScore;
                double aPredScore = defaultArticlePredScore;
                double noArticlePredScore = defaultArticlePredScore;

                for (Prediction p : articlePredictions) {
                    if (p.getValue().equals("the")) {
                        thePredScore = Math.max(thePredScore, p.getScore());
                    } else if (p.getValue().equals("a")) {
                        aPredScore = Math.max(aPredScore, p.getScore());
                    } else if (p.getValue().isEmpty()) {
                        noArticlePredScore =
                            Math.max(noArticlePredScore, p.getScore());
                    }
                }

                thePredScore += defaultArticleSmoothing;
                aPredScore += defaultArticleSmoothing;
                noArticlePredScore += defaultArticleSmoothing;

                thePredScore = Math.log(thePredScore);
                aPredScore = Math.log(aPredScore);
                noArticlePredScore = Math.log(noArticlePredScore);

                double scoreWithThe = articleLmWeight
                        * scoreNonemptyContext(aw, "the", result, 2, false)
                    + (1 - articleLmWeight) * thePredScore;
                double scoreWithA = articleLmWeight
                        * scoreNonemptyContext(aw, "a", result, 2, false)
                    + (1 - articleLmWeight) * aPredScore;
                double scoreWithAn = articleLmWeight
                        * scoreNonemptyContext(aw, "an", result, 2, false)
                    + (1 - articleLmWeight) * aPredScore;
                double scoreWithoutArticle =
                    articleLmWeight * scoreNonemptyContext(aw, result, 2, false)
                    + (1 - articleLmWeight) * noArticlePredScore;

                String bestArticle = "the";
                double bestArticleScore = scoreWithThe;
                if (scoreWithA > bestArticleScore) {
                    bestArticle = "a";
                    bestArticleScore = scoreWithA;
                }
                if (scoreWithAn > bestArticleScore) {
                    bestArticle = "an";
                    bestArticleScore = scoreWithAn;
                }
                if (bestArticleScore
                        > scoreWithoutArticle * articleAdditionHandicap
                    && !SecondStageProcessor.articleDisallowed(aw.alignment)) {
                    aw.word = bestArticle;
                    amr.partialTransitionFunction.denominator.put(
                        aw.alignment, aw.word);
                }
            }
        }
    }

    /**
     * Computes the language model score of a local context of nonempty words
     * around a given word.
     * @param word the word for which the context should be scored
     * @param sentence the sentence in which the word is embedded
     * @param contextSize the context size. Let {@code i} denote the position of
     * {@code word}; then the words at positions {@code i - contextSize, i -
     * contextSize + 1, ..., i, i + 1, ..., i + contextSize} are considered.
     * @param withPunctuation whether punctuation should be included
     * @return the language model score of the context
     */
    private double scoreNonemptyContext(AlignedWord word,
        List<AlignedWord> sentence, int contextSize, boolean withPunctuation) {
        return scoreNonemptyContext(
            word, word.word, sentence, contextSize, withPunctuation);
    }

    /**
     * Computes the language model score of a local context of nonempty words
     * around a given word if said word is replaced by another word.
     * @param word the word for which the context should be scored
     * @param insertionForAw the word by which {@code word} shall be replaced
     * @param sentence the sentence in which the word is embedded
     * @param contextSize the context size. Let {@code i} denote the position of
     * {@code word}; then the words at positions {@code i - contextSize, i -
     * contextSize + 1, ..., i, i + 1, ..., i + contextSize} are considered.
     * @param withPunctuation whether punctuation should be included
     * @return the language model score of the context
     */
    private double scoreNonemptyContext(AlignedWord word, String insertionForAw,
        List<AlignedWord> sentence, int contextSize, boolean withPunctuation) {
        List<String> nonemptyContext = getNonemptyContext(
            word, insertionForAw, sentence, contextSize, withPunctuation);
        return SecondStageProcessor.scoreSentence(
            nonemptyContext, lm, false, false);
    }

    /**
     * Returns a local context of nonempty words around a given word where said
     * word is replaced by another word. The local context is represented by a
     * list of strings.
     * @param word the word for which the context should be computed
     * @param insertionForAw the word by which {@code word} shall be replaced
     * @param sentence the sentence in which the word is embedded
     * @param contextSize the context size. Let {@code i} denote the position of
     * {@code word}; then the words at positions {@code i - contextSize, i -
     * contextSize + 1, ..., i, i + 1, ..., i + contextSize} are considered.
     * @param withPunctuation whether punctuation should be included
     * @return the context
     */
    private List<String> getNonemptyContext(AlignedWord word,
        String insertionForAw, List<AlignedWord> sentence, int contextSize,
        boolean withPunctuation) {
        List<AlignedWord> ret =
            sentence.stream()
                .filter(e
                    -> (!e.word.isEmpty()
                           && (e.type != AlignmentType.PUNCTUATION
                                  || withPunctuation))
                        || (e == word))
                .collect(Collectors.toList());
        int wordIndex = ret.indexOf(word);

        List<String> retString =
            ret.stream().map(e -> e.word).collect(Collectors.toList());

        BoundedList<String> retBounded =
            new BoundedList<>(retString, lm.getWordIndexer().getStartSymbol(),
                lm.getWordIndexer().getEndSymbol());

        List<String> leftSide =
            retBounded.subList(wordIndex - contextSize, wordIndex);
        List<String> rightSide =
            retBounded.subList(wordIndex + 1, wordIndex + contextSize + 1);

        String lsString = String.join(" ", leftSide);
        String rsString = String.join(" ", rightSide);
        List<String> ls = Arrays.asList(lsString.split(" "));
        List<String> rs = Arrays.asList(rsString.split(" "));

        List<String> finalRet = new ArrayList<>();
        finalRet.addAll(ls.subList(ls.size() - contextSize, ls.size()));
        if (!insertionForAw.isEmpty())
            finalRet.add(insertionForAw);
        finalRet.addAll(rs.subList(0, contextSize));

        return finalRet;
    }

    /**
     * This function checks whether a word of a sentence generated from some AMR
     * graph is allowed to have an article. A word is not allowed to have an
     * article, if one of the following holds: <ul> <li>the word directly to its
     * left or right already is an article;</li> <li>the corresponding vertex is
     * an instance of the concept "person" and has a name;</li> <li>the word is
     * empty.</li>
     * </ul>
     * @param amr the AMR graph from which the sentence was created
     * @param aws the sentence, represented as a list of {@code AlignedWord}s
     * @param aw the word to check
     * @return true iff the word is allowed to have an article
     */
    private boolean canHaveArticle(
        Amr amr, List<AlignedWord> aws, AlignedWord aw) {
        List<String> context = getNonemptyContext(aw, "", aws, 1, false);

        if (!Collections.disjoint(context, WordLists.articles))
            return false;

        if (aw.alignment.getInstance().equals("person")
            && !aw.alignment.name.isEmpty())
            return false;
        if (amr.partialTransitionFunction.realization.get(aw.alignment)
                .isEmpty())
            return false;

        return true;
    }
}
